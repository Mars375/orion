---
phase: 06-edge-integration
plan: 03
type: execute
depends_on: ["06-02"]
files_modified: [edge/internal/safety/watchdog.go, edge/internal/safety/watchdog_test.go, edge/internal/safety/safe_state.go, edge/cmd/orion-edge/main.go]
---

<objective>
Implement the Dead Man's Switch watchdog and "Sit & Freeze" safe state logic.

Purpose: Ensure the edge device enters a safe state if communication with Brain is lost - this is the CRITICAL safety feature for Phase 6.
Output: Watchdog timer that triggers safe state after timeout, safe state stub for kinematics.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/06-edge-integration/06-CONTEXT.md
@.planning/phases/06-edge-integration/06-RESEARCH.md
@.planning/phases/06-edge-integration/06-02-SUMMARY.md

**From CONTEXT.md (CRITICAL):**
- "When network is lost, the robot freezes in place immediately. This is non-negotiable."
- "Dead Man's Switch â€” Pi 4 must independently trigger 'Sit & Freeze' safety state if it loses network connection to Brain. This logic runs locally on the edge, not dependent on any remote command."

**From RESEARCH.md:**
- Watchdog pattern: time.AfterFunc with Reset() method
- 3-5 second timeout recommended
- Resume ONLY with explicit command after reconnection (never auto-resume)
- Integration with MQTT OnConnectionDown callback

**ORION Safety Philosophy:**
- Conservative by default
- Inaction preferred to risky action
- Fail-closed behavior throughout
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DeadManSwitch watchdog timer</name>
  <files>edge/internal/safety/watchdog.go, edge/internal/safety/watchdog_test.go</files>
  <action>
Create the Dead Man's Switch watchdog implementation.

**edge/internal/safety/watchdog.go:**

```go
// DeadManSwitch monitors Brain connectivity and triggers safe state on timeout.
//
// Invariants:
//   - Watchdog MUST be Reset() on every heartbeat/command from Brain
//   - Timeout triggers safe state callback (non-reversible without explicit resume)
//   - Safe state callback runs ONCE per trigger (idempotent)
//   - Thread-safe (concurrent Reset calls from multiple goroutines)
type DeadManSwitch struct {
    timeout     time.Duration
    timer       *time.Timer
    mu          sync.Mutex
    triggered   bool
    onTrigger   func()  // Called when watchdog expires
    logger      *log.Logger
}
```

Methods:
- NewDeadManSwitch(timeout time.Duration, onTrigger func()) *DeadManSwitch
  - Creates watchdog, starts timer immediately
  - onTrigger is called when timeout expires (runs in timer goroutine)
- Reset()
  - Resets timer to full timeout duration
  - No-op if already triggered (safe state is sticky)
  - Thread-safe with mutex
- Stop()
  - Stops the timer (for cleanup)
- IsTriggered() bool
  - Returns true if safe state was triggered
- ClearTriggered()
  - Allows resumption (called only on explicit RESUME command from Brain)
  - Logs warning: "Dead Man's Switch cleared - resuming operations"

**edge/internal/safety/watchdog_test.go:**

Unit tests (at least 6):
1. test_watchdog_triggers_after_timeout - Timer expires, callback runs
2. test_watchdog_reset_prevents_trigger - Reset before timeout prevents callback
3. test_watchdog_triggered_state_sticky - After trigger, Reset() does not clear
4. test_watchdog_clear_allows_resume - ClearTriggered() resets triggered flag
5. test_watchdog_callback_runs_once - Multiple timeouts only call callback once
6. test_watchdog_concurrent_reset_safe - Concurrent Reset() calls don't race

Use short timeouts (50-100ms) for tests to run fast.
  </action>
  <verify>cd /home/orion/orion/edge && go test -v -race ./internal/safety/...</verify>
  <done>DeadManSwitch implementation with 6+ passing tests, thread-safe, triggered state is sticky</done>
</task>

<task type="auto">
  <name>Task 2: Implement SafeState manager for "Sit & Freeze"</name>
  <files>edge/internal/safety/safe_state.go</files>
  <action>
Create the safe state manager that handles "Sit & Freeze" behavior.

**edge/internal/safety/safe_state.go:**

```go
// SafeStateManager handles the "Sit & Freeze" safe state for edge devices.
//
// When triggered:
//   1. Stops all movement immediately
//   2. Moves to safe position (stub in Phase 6)
//   3. Disables autonomous movement
//   4. Publishes health with state=SAFE_MODE
//
// Resumption requires explicit RESUME command from Brain after reconnection.
type SafeStateManager struct {
    inSafeMode    bool
    mu            sync.Mutex
    logger        *log.Logger
    onEnterSafe   func()  // Callback for kinematics (stub)
    onExitSafe    func()  // Callback for resumption (stub)
}
```

Methods:
- NewSafeStateManager(onEnter, onExit func()) *SafeStateManager
- EnterSafeMode()
  - Sets inSafeMode = true
  - Calls onEnterSafe() callback (kinematics stub)
  - Logs: "SAFETY: Entering safe mode - Sit & Freeze"
  - Thread-safe
- ExitSafeMode() error
  - Only exits if currently in safe mode
  - Calls onExitSafe() callback
  - Logs: "SAFETY: Exiting safe mode - resuming operations"
  - Returns error if not in safe mode
- IsInSafeMode() bool
- GetSafePosition() map[string]interface{}
  - Returns stub position data for "Sit & Freeze" posture
  - Returns: {"state": "sit_freeze", "height": 0.0, "legs_folded": true}

The onEnterSafe/onExitSafe callbacks are stubs in Phase 6 - actual kinematics implementation is Phase 7 or later.

Add tests for SafeStateManager (at least 4):
1. test_enter_safe_mode_sets_flag
2. test_exit_safe_mode_clears_flag
3. test_exit_when_not_safe_returns_error
4. test_get_safe_position_returns_stub
  </action>
  <verify>cd /home/orion/orion/edge && go test -v ./internal/safety/...</verify>
  <done>SafeStateManager with stub callbacks, 4+ tests passing</done>
</task>

<task type="auto">
  <name>Task 3: Integrate watchdog and safe state into main agent</name>
  <files>edge/cmd/orion-edge/main.go</files>
  <action>
Integrate the Dead Man's Switch into the main agent lifecycle.

Update main.go to:

1. Create SafeStateManager with stub callbacks:
   ```go
   safeState := safety.NewSafeStateManager(
       func() { log.Println("STUB: Would move to Sit & Freeze position") },
       func() { log.Println("STUB: Would resume normal operations") },
   )
   ```

2. Create DeadManSwitch with configured timeout:
   ```go
   watchdog := safety.NewDeadManSwitch(
       time.Duration(cfg.WatchdogTimeoutSec) * time.Second,
       func() {
           log.Println("SAFETY: Dead Man's Switch triggered!")
           safeState.EnterSafeMode()
       },
   )
   ```

3. Wire MQTT callbacks:
   - OnConnectionUp: watchdog.Reset(), log "Brain connection restored"
   - OnConnectionDown: log "Brain connection lost - watchdog active"
   - Do NOT clear watchdog on reconnect (wait for explicit RESUME)

4. Wire Redis callbacks (if using Redis for commands):
   - On successful command receive: watchdog.Reset()

5. Update heartbeat publisher to include safety state:
   ```go
   health := map[string]interface{}{
       "state": getState(safeState),  // RUNNING, SAFE_MODE, etc.
       "safety_state": map[string]interface{}{
           "dead_man_switch_active": !mqttClient.IsConnected(),
           "watchdog_remaining_ms": watchdog.RemainingMs(),
           "in_safe_position": safeState.IsInSafeMode(),
       },
       ...
   }
   ```

6. Add command handler for RESUME:
   ```go
   case "RESUME":
       if safeState.IsInSafeMode() {
           watchdog.ClearTriggered()
           safeState.ExitSafeMode()
           log.Println("Received RESUME command - exiting safe mode")
       }
   ```

7. Update health endpoint to show safety state:
   ```json
   {
       "status": "ok",
       "service": "orion-edge",
       "device_id": "hexapod-1",
       "safe_mode": false,
       "watchdog_triggered": false,
       "version": "0.1.0"
   }
   ```

Log all safety state transitions clearly for debugging.
  </action>
  <verify>cd /home/orion/orion/edge && make build && ./bin/orion-edge --help</verify>
  <done>Main agent integrates watchdog and safe state, health endpoint shows safety status</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go test -v -race ./internal/safety/...` passes (10+ tests)
- [ ] DeadManSwitch triggers callback after timeout
- [ ] DeadManSwitch.Reset() prevents trigger
- [ ] Triggered state is sticky (no auto-resume)
- [ ] SafeStateManager enters/exits safe mode correctly
- [ ] Main agent compiles with safety integration
- [ ] Health endpoint includes safe_mode and watchdog_triggered fields
- [ ] RESUME command handling implemented (stub for now)
</verification>

<success_criteria>
- Dead Man's Switch watchdog implemented with comprehensive tests
- Safe state manager provides "Sit & Freeze" stub
- Main agent integrates safety components
- All safety state transitions logged
- Health endpoint reports safety status
- No auto-resume after connection loss (explicit RESUME required)
</success_criteria>

<output>
After completion, create `.planning/phases/06-edge-integration/06-03-SUMMARY.md`
</output>
