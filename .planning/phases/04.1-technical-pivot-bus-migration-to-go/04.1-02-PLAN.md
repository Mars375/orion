---
phase: 04.1-technical-pivot-bus-migration-to-go
plan: 02
type: execute
depends_on: ["04.1-01"]
files_modified: [bus/go/internal/bus/bus.go, bus/go/internal/bus/bus_test.go, bus/go/internal/shutdown/shutdown.go, bus/go/internal/shutdown/shutdown_test.go]
---

<objective>
Implement core EventBus with go-redis integration and graceful shutdown.

Purpose: Build Redis Streams publish/subscribe functionality with worker pool pattern
Output: EventBus package with tests, graceful shutdown coordinator
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04.1-technical-pivot-bus-migration-to-go/04.1-RESEARCH.md
@.planning/phases/04.1-technical-pivot-bus-migration-to-go/04.1-01-SUMMARY.md
@bus/python/orion_bus/bus.py
@bus/contracts/event.schema.json

**Tech Stack Available**:
- Go module with go-redis/v9, uuid, testify (from Plan 01)
- Redis 7 (Alpine) running locally
- Python bus implementation as reference

**Established Patterns**:
- Redis Streams consumer groups with XREADGROUP
- Contract validation at boundaries (deferred to Plan 03)
- Bounded memory usage (maxlen on streams)

**Constraining Decisions**:
- Plan 01: Go project structure established
- RESEARCH.md: go-redis/v9 for stability, worker pool pattern for concurrency
- ARCHITECTURE.md: Fail-fast on errors, graceful shutdown mandatory
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement EventBus with go-redis</name>
  <files>bus/go/internal/bus/bus.go</files>
  <action>
    Create EventBus struct in internal/bus/bus.go implementing:

    **Struct definition**:
    ```go
    type EventBus struct {
        client       *redis.Client
        streamPrefix string
        maxLen       int64
        logger       *log.Logger
    }
    ```

    **Constructor (NewEventBus)**:
    - Accept redis.Client, streamPrefix, maxLen
    - Initialize logger
    - Return EventBus pointer

    **Methods to implement**:

    1. `Publish(ctx context.Context, message map[string]interface{}, contractType string) (string, error)`
       - Get stream name: `{prefix}:{contractType}s` (e.g., "orion:events")
       - Marshal message to JSON
       - Use XAdd with maxlen (approximate trimming for performance)
       - Return message ID or error
       - Log publish at DEBUG level

    2. `Subscribe(ctx context.Context, contractType string, consumerGroup string, consumerName string, handler func(map[string]interface{}) error) error`
       - Create consumer group if not exists (XGroupCreateMkStream, ignore BUSYGROUP error)
       - Loop: XReadGroup with Block=1000ms, Count=10
       - For each message: unmarshal JSON, call handler, XAck if handler succeeds
       - Handle context cancellation (return when ctx.Done())
       - Log subscription start/stop at INFO level

    **Error handling**:
    - Wrap Redis errors with context
    - Return immediately on context cancellation
    - DO NOT retry failed handlers (handler responsibility)

    **Connection pool config** (from RESEARCH.md):
    - PoolSize: 100 (Phase 5 AI Council concurrency)
    - MinIdleConns: 10 (reduce latency)
    - ConnMaxLifetime: 1 hour

    Follow Go conventions: exported types/functions PascalCase, unexported camelCase.
    Add comprehensive docstrings for all exported functions.
  </action>
  <verify>go build ./internal/bus compiles without errors</verify>
  <done>EventBus implements Publish and Subscribe with go-redis, proper error handling</done>
</task>

<task type="auto">
  <name>Task 2: Add EventBus unit tests</name>
  <files>bus/go/internal/bus/bus_test.go</files>
  <action>
    Create comprehensive unit tests for EventBus using testify and miniredis (in-memory Redis mock).

    Add dependency: `github.com/alicebob/miniredis/v2` (in-memory Redis for testing)

    **Tests to implement**:

    1. `TestPublish_ValidMessage_ReturnsMessageID`
       - Create miniredis server
       - Publish valid message
       - Verify message ID returned
       - Verify message exists in Redis stream

    2. `TestPublish_RedisDown_ReturnsError`
       - Close miniredis server
       - Attempt publish
       - Verify error returned

    3. `TestSubscribe_ConsumerGroupCreated`
       - Subscribe with new consumer group
       - Verify group exists via XINFO GROUPS

    4. `TestSubscribe_HandlerCalled_MessageAcknowledged`
       - Publish message to stream
       - Subscribe with handler that records calls
       - Verify handler called with message
       - Verify message acknowledged (no pending messages)

    5. `TestSubscribe_ContextCancellation_ReturnsCleanly`
       - Start subscription with cancellable context
       - Cancel context
       - Verify Subscribe returns within 2 seconds

    Use `testify/assert` for assertions. Use `testify/require` for fatal errors (setup failures).

    Follow ORION testing conventions:
    - Test names: `Test<Method>_<Condition>_<Expected>`
    - Setup/teardown: Use t.Cleanup() for resource cleanup
    - Parallel tests: Use t.Parallel() for independent tests
  </action>
  <verify>go test ./internal/bus -v passes all tests, coverage >80%</verify>
  <done>5 unit tests passing, EventBus behavior verified</done>
</task>

<task type="auto">
  <name>Task 3: Implement graceful shutdown coordinator</name>
  <files>bus/go/internal/shutdown/shutdown.go, bus/go/internal/shutdown/shutdown_test.go</files>
  <action>
    Create shutdown coordinator in internal/shutdown/shutdown.go for graceful termination.

    **Struct definition**:
    ```go
    type Coordinator struct {
        timeout time.Duration
        logger  *log.Logger
    }
    ```

    **Method**:
    `WaitForShutdown(ctx context.Context, cleanupFuncs ...func(context.Context) error) error`
    - Wait for ctx.Done() (signal.NotifyContext from main.go)
    - Log shutdown initiated
    - Create timeout context (default: 25 seconds, < K8s terminationGracePeriod)
    - Execute all cleanupFuncs with timeout context
    - Collect errors from cleanup functions
    - Log completion or timeout
    - Return combined error if any cleanup failed

    **Pattern from RESEARCH.md**:
    - Shutdown timeout < Kubernetes terminationGracePeriodSeconds (30s default)
    - Use 25s timeout to allow 5s buffer
    - Propagate context cancellation to all cleanup functions

    **Unit tests** (in shutdown_test.go):
    1. `TestWaitForShutdown_AllCleanupSucceeds`
       - Cancel context, verify all cleanup funcs called
    2. `TestWaitForShutdown_CleanupTimeout`
       - Cleanup func sleeps >timeout, verify timeout error
    3. `TestWaitForShutdown_CleanupError`
       - Cleanup func returns error, verify error propagated

    Add docstrings explaining shutdown pattern and timeout rationale.
  </action>
  <verify>go test ./internal/shutdown -v passes all 3 tests</verify>
  <done>Shutdown coordinator implements graceful termination with timeout, tests passing</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go test ./internal/... -v -race` passes all tests
- [ ] `go build ./internal/...` compiles without errors or warnings
- [ ] Coverage report shows >80% for bus package
- [ ] No data races detected by race detector
- [ ] All exported functions have docstrings
</verification>

<success_criteria>

- EventBus implements Publish and Subscribe using go-redis/v9
- Unit tests verify publish, subscribe, consumer groups, context cancellation
- Graceful shutdown coordinator with 25s timeout
- All tests pass with race detector enabled
- Coverage >80% for core bus logic
- No errors or warnings from go toolchain
  </success_criteria>

<output>
After completion, create `.planning/phases/04.1-technical-pivot-bus-migration-to-go/04.1-02-SUMMARY.md`:

# Phase 4.1 Plan 02: Core Bus Implementation Summary

**Go EventBus operational with Redis Streams and graceful shutdown**

## Accomplishments

- EventBus package with Publish and Subscribe methods
- go-redis/v9 integration with consumer groups
- 5 unit tests for bus (miniredis for isolation)
- Graceful shutdown coordinator with 25s timeout
- 3 unit tests for shutdown coordinator
- Coverage >80% for core logic

## Files Created/Modified

- `bus/go/internal/bus/bus.go` - EventBus implementation
- `bus/go/internal/bus/bus_test.go` - Unit tests with miniredis
- `bus/go/internal/shutdown/shutdown.go` - Shutdown coordinator
- `bus/go/internal/shutdown/shutdown_test.go` - Shutdown tests
- `bus/go/go.mod` - Added miniredis dependency

## Decisions Made

- Using miniredis/v2 for unit testing (in-memory Redis mock)
- 25s shutdown timeout (5s buffer before K8s termination)
- XReadGroup with Block=1000ms, Count=10 (balanced latency/throughput)
- Approximate maxlen trimming for performance

## Issues Encountered

None

## Next Step

Ready for 04.1-03-PLAN.md (JSON Schema Validation + Code Generation)
</output>
