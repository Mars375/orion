---
phase: 07-compute-expansion
plan: 02
type: execute
depends_on: ["07-01"]
files_modified: [core/inference/router/router.go, core/inference/router/health.go, core/inference/router/sticky.go, core/inference/router/router_test.go]
---

<objective>
Implement inference router service with sticky routing and health-aware node selection.

Purpose: The router receives inference requests from Brain, selects the optimal node based on model residency (sticky routing) and health metrics, and dispatches requests to workers via Redis Streams.
Output: Router service that implements sticky routing algorithm with health-aware backoff.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/07-compute-expansion/07-CONTEXT.md
@.planning/phases/07-compute-expansion/07-RESEARCH.md
@.planning/phases/07-compute-expansion/07-01-SUMMARY.md
@core/inference/contracts/inference.go

**Routing strategy (from CONTEXT.md):**
- Sticky routing: Prefer nodes with model already resident to avoid cold-start latency
- Health-aware: Route based on node health, memory pressure, load
- Safety backoff: Auto-mark unavailable at temp > 75°C or RAM > 90%

**Patterns from RESEARCH.md:**
```go
// First pass: prefer nodes with model already loaded
for _, n := range nodes {
    if slices.Contains(n.Models, model) && n.Available {
        return n.NodeID, nil
    }
}

// Second pass: select least loaded healthy node
sort.Slice(nodes, func(i, j int) bool {
    return nodes[i].RAMPercent < nodes[j].RAMPercent
})
```

**Redis Streams pattern for async requests:**
- Brain submits to "orion:inference:requests"
- Router reads and dispatches to "orion:inference:requests:{nodeID}"
- Worker responds to callback stream
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement health registry reader</name>
  <files>core/inference/router/health.go, core/inference/router/health_test.go</files>
  <action>
Create health registry reader that fetches node health for routing decisions:

1. Create HealthReader struct:
   - Fields: redis *redis.Client, keyPrefix string, staleDuration time.Duration
   - Constructor: NewHealthReader(redis *redis.Client, keyPrefix string)
   - Default staleDuration: 15 seconds

2. Implement GetHealthyNodes(ctx context.Context) ([]NodeHealth, error):
   - Read all entries from "orion:inference:health" hash via HGETALL
   - Parse each JSON entry to NodeHealth
   - Filter out stale nodes (LastSeen > staleDuration ago)
   - Filter out unavailable nodes (Available == false)
   - Return sorted by RAMPercent ascending (least loaded first)

3. Implement GetNodeHealth(ctx context.Context, nodeID string) (*NodeHealth, error):
   - Read single entry from hash via HGET
   - Return nil if not found or stale
   - Return error only for Redis failures

4. Implement IsNodeHealthy(health NodeHealth) bool:
   - Check TempCelsius <= 75
   - Check RAMPercent <= 90
   - Check LastSeen within staleDuration
   - All conditions must pass

5. Write unit tests using miniredis:
   - Test GetHealthyNodes filters stale entries
   - Test GetHealthyNodes filters unavailable nodes
   - Test sorting by RAM percent
   - Test IsNodeHealthy thresholds

AVOID: Caching health data (always read fresh for routing decisions).
  </action>
  <verify>go test ./router/... -v passes health tests, filtering logic correct</verify>
  <done>HealthReader implemented with stale detection and availability filtering</done>
</task>

<task type="auto">
  <name>Task 2: Implement sticky routing algorithm</name>
  <files>core/inference/router/sticky.go, core/inference/router/sticky_test.go</files>
  <action>
Create sticky routing algorithm that prioritizes model residency:

1. Create StickyRouter struct:
   - Fields: healthReader *HealthReader
   - Constructor: NewStickyRouter(healthReader *HealthReader)

2. Implement SelectNode(ctx context.Context, model string) (string, error):
   - Get all healthy nodes via healthReader.GetHealthyNodes()
   - If no healthy nodes: return "", ErrNoAvailableNodes

   - First pass (model resident):
     - Iterate nodes in RAM-sorted order
     - If node.Models contains requested model AND node.Available:
       - Return node.NodeID immediately (sticky hit)

   - Second pass (load-based):
     - Return first node in list (already sorted by RAM, least loaded)

3. Define errors:
   - var ErrNoAvailableNodes = errors.New("no available inference nodes")

4. Implement GetModelResidency(nodes []NodeHealth, model string) []string:
   - Return list of nodeIDs that have the model loaded
   - Useful for metrics and debugging

5. Write unit tests:
   - Test sticky routing returns node with model loaded
   - Test fallback to least-loaded node when model not resident
   - Test ErrNoAvailableNodes when no healthy nodes
   - Test with multiple nodes having same model (should pick least loaded)

Pattern insight (from RESEARCH.md): With only 2-3 nodes, simple preference lists beat complex consistent hashing. Don't over-engineer.
  </action>
  <verify>go test ./router/... -v passes sticky tests, routing logic matches RESEARCH.md patterns</verify>
  <done>StickyRouter implemented with model-resident preference and load-based fallback</done>
</task>

<task type="auto">
  <name>Task 3: Implement inference router with Redis Streams dispatch</name>
  <files>core/inference/router/router.go, core/inference/router/router_test.go</files>
  <action>
Create main router service that receives requests and dispatches to workers:

1. Create InferenceRouter struct:
   - Fields: redis *redis.Client, sticky *StickyRouter, streamPrefix string
   - Constructor: NewInferenceRouter(redis *redis.Client, sticky *StickyRouter, streamPrefix string)

2. Implement RouteRequest(ctx context.Context, req InferenceRequest) error:
   - Select node via sticky.SelectNode(ctx, req.Model)
   - If ErrNoAvailableNodes: return error (caller handles retry/queue)
   - Dispatch to worker's stream: "orion:inference:requests:{nodeID}"
   - Use XADD with MAXLEN ~ 1000 (auto-trim old requests)
   - Log: "Routing request %s for model %s to node %s"

3. Implement ConsumeRequests(ctx context.Context) error:
   - Create consumer group on "orion:inference:requests" stream
   - Read messages via XReadGroup with 5s block timeout
   - For each message:
     - Parse to InferenceRequest
     - Call RouteRequest
     - ACK message
   - Run until context cancelled

4. Implement GetRoutingStats(ctx context.Context) map[string]interface{}:
   - Count requests routed per node
   - Count sticky hits vs fallback
   - For observability/debugging

5. Write unit tests using miniredis:
   - Test RouteRequest dispatches to correct stream
   - Test ConsumeRequests processes messages
   - Test error handling when no nodes available

Follow async pattern from RESEARCH.md: Decouple request submission from response retrieval. Brain submits and continues.
  </action>
  <verify>go test ./router/... -v passes all router tests, Redis streams operations correct</verify>
  <done>InferenceRouter implemented with sticky dispatch and consumer group processing</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds in core/inference/
- [ ] `go test ./router/...` passes all tests
- [ ] HealthReader correctly filters stale and unavailable nodes
- [ ] StickyRouter prefers model-resident nodes
- [ ] StickyRouter falls back to least-loaded node
- [ ] InferenceRouter dispatches to node-specific streams
- [ ] All Redis operations use correct stream names
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Sticky routing algorithm matches RESEARCH.md patterns
- Health-aware filtering respects 75°C temp and 90% RAM thresholds
- Router integrates with Redis Streams for async dispatch
</success_criteria>

<output>
After completion, create `.planning/phases/07-compute-expansion/07-02-SUMMARY.md`:

# Phase 7 Plan 02: Router Service Summary

**[Substantive one-liner describing what shipped]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.go` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 07-03-PLAN.md (Integration & Testing)
</output>
